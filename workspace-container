#!/usr/bin/env bash

# workspace-container - A container lifecycle management tool
# Similar to distrobox, designed for macOS with Podman

set -e

SCRIPT_NAME="workspace-container"
CONTAINER_PREFIX="workspace"
DEFAULT_CONTAINER_NAME="${CONTAINER_PREFIX}-default"
IMAGE_NAME="workspace-container"
CONFIG_DIR="${HOME}/.config/${SCRIPT_NAME}"
CONTAINER_LIST_FILE="${CONFIG_DIR}/containers.list"

# Ensure config directory exists
mkdir -p "${CONFIG_DIR}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Helper functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $*"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $*"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $*"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $*"
}

# Check if podman is installed
check_podman() {
    if ! command -v podman &> /dev/null; then
        log_error "podman is not installed. Please install podman first."
        exit 1
    fi
}

# Build the container image
build_image() {
    local dockerfile_path="${1:-./Dockerfile}"
    
    if [ ! -f "${dockerfile_path}" ]; then
        log_error "Dockerfile not found at: ${dockerfile_path}"
        exit 1
    fi
    
    log_info "Building container image: ${IMAGE_NAME}"
    
    # Get current user UID and GID
    local uid=$(id -u)
    local gid=$(id -g)
    local username=$(whoami)
    
    podman build \
        --build-arg USERNAME="${username}" \
        --build-arg USER_UID="${uid}" \
        --build-arg USER_GID="${gid}" \
        -t "${IMAGE_NAME}" \
        -f "${dockerfile_path}" \
        "$(dirname "${dockerfile_path}")"
    
    if [ $? -eq 0 ]; then
        log_success "Image built successfully: ${IMAGE_NAME}"
    else
        log_error "Failed to build image"
        exit 1
    fi
}

# Add container to the list
add_to_container_list() {
    local container_name="$1"
    touch "${CONTAINER_LIST_FILE}"
    if ! grep -q "^${container_name}$" "${CONTAINER_LIST_FILE}"; then
        echo "${container_name}" >> "${CONTAINER_LIST_FILE}"
    fi
}

# Remove container from the list
remove_from_container_list() {
    local container_name="$1"
    if [ -f "${CONTAINER_LIST_FILE}" ]; then
        # Create temp file and use it to avoid sed -i compatibility issues
        grep -v "^${container_name}$" "${CONTAINER_LIST_FILE}" > "${CONTAINER_LIST_FILE}.tmp" || true
        mv "${CONTAINER_LIST_FILE}.tmp" "${CONTAINER_LIST_FILE}"
    fi
}

# Create a new container
create_container() {
    local container_name="${1:-${DEFAULT_CONTAINER_NAME}}"
    
    check_podman
    
    # Check if container already exists
    if podman container exists "${container_name}" 2>/dev/null; then
        log_warning "Container '${container_name}' already exists."
        return 0
    fi
    
    # Check if image exists, if not build it
    if ! podman image exists "${IMAGE_NAME}" 2>/dev/null; then
        log_info "Image '${IMAGE_NAME}' not found. Building..."
        build_image
    fi
    
    log_info "Creating container: ${container_name}"
    
    # Prepare volume mounts for config files
    local volumes=""
    local home_dir="${HOME}"
    
    # Mount common config directories/files if they exist
    local configs=(
        ".zshrc"
        ".config/nvim"
        ".vimrc"
        ".bashrc"
        ".gitconfig"
        ".ssh"
    )
    
    for config in "${configs[@]}"; do
        local host_path="${home_dir}/${config}"
        if [ -e "${host_path}" ]; then
            volumes="${volumes} -v ${host_path}:/home/$(whoami)/${config}"
        fi
    done
    
    # Create the container
    podman create \
        --name "${container_name}" \
        --hostname "${container_name}" \
        --network host \
        ${volumes} \
        -v "${home_dir}:/host-home:ro" \
        -it \
        "${IMAGE_NAME}"
    
    if [ $? -eq 0 ]; then
        add_to_container_list "${container_name}"
        log_success "Container '${container_name}' created successfully"
        log_info "Use '${SCRIPT_NAME} enter ${container_name}' to enter the container"
    else
        log_error "Failed to create container '${container_name}'"
        exit 1
    fi
}

# Enter an existing container
enter_container() {
    local container_name="${1:-${DEFAULT_CONTAINER_NAME}}"
    
    check_podman
    
    # Check if container exists
    if ! podman container exists "${container_name}" 2>/dev/null; then
        log_error "Container '${container_name}' does not exist."
        log_info "Create it first with: ${SCRIPT_NAME} create ${container_name}"
        exit 1
    fi
    
    # Check if container is running, if not start it
    if [ "$(podman inspect -f '{{.State.Running}}' "${container_name}" 2>/dev/null)" != "true" ]; then
        log_info "Starting container: ${container_name}"
        podman start "${container_name}" > /dev/null
    fi
    
    log_info "Entering container: ${container_name}"
    
    # Enter the container
    podman exec -it -u "$(whoami)" "${container_name}" /bin/zsh
}

# Destroy a container
destroy_container() {
    local container_name="${1:-${DEFAULT_CONTAINER_NAME}}"
    
    check_podman
    
    # Check if container exists
    if ! podman container exists "${container_name}" 2>/dev/null; then
        log_warning "Container '${container_name}' does not exist."
        return 0
    fi
    
    log_info "Destroying container: ${container_name}"
    
    # Stop and remove the container
    podman stop "${container_name}" 2>/dev/null || true
    podman rm -f "${container_name}"
    
    if [ $? -eq 0 ]; then
        remove_from_container_list "${container_name}"
        log_success "Container '${container_name}' destroyed successfully"
    else
        log_error "Failed to destroy container '${container_name}'"
        exit 1
    fi
}

# List all managed containers
list_containers() {
    check_podman
    
    log_info "Managed containers:"
    
    if [ ! -f "${CONTAINER_LIST_FILE}" ] || [ ! -s "${CONTAINER_LIST_FILE}" ]; then
        echo "  No containers found"
        return 0
    fi
    
    while IFS= read -r container_name; do
        if podman container exists "${container_name}" 2>/dev/null; then
            local status=$(podman inspect -f '{{.State.Status}}' "${container_name}")
            echo "  - ${container_name} (${status})"
        else
            # Container was removed outside of this tool
            remove_from_container_list "${container_name}"
        fi
    done < "${CONTAINER_LIST_FILE}"
}

# Display help
show_help() {
    cat << EOF
${SCRIPT_NAME} - Container lifecycle management tool

Usage: ${SCRIPT_NAME} <command> [container-name]

Commands:
    create [name]   Create a new container (default: ${DEFAULT_CONTAINER_NAME})
    enter [name]    Enter an existing container (default: ${DEFAULT_CONTAINER_NAME})
    destroy [name]  Destroy a container (default: ${DEFAULT_CONTAINER_NAME})
    list            List all managed containers
    build           Build/rebuild the container image
    help            Show this help message

Examples:
    ${SCRIPT_NAME} create                    # Create default container
    ${SCRIPT_NAME} create myworkspace        # Create named container
    ${SCRIPT_NAME} enter                     # Enter default container
    ${SCRIPT_NAME} enter myworkspace         # Enter named container
    ${SCRIPT_NAME} destroy myworkspace       # Destroy named container
    ${SCRIPT_NAME} list                      # List all containers

The container will mount your home directory config files for:
  - .zshrc, .bashrc, .gitconfig
  - .config/nvim, .vimrc
  - .ssh

Your full home directory is also available at /host-home (read-only)

EOF
}

# Main command dispatcher
main() {
    local command="${1:-help}"
    local container_name="${2:-}"
    
    case "${command}" in
        create)
            create_container "${container_name}"
            ;;
        enter)
            enter_container "${container_name}"
            ;;
        destroy)
            destroy_container "${container_name}"
            ;;
        list)
            list_containers
            ;;
        build)
            build_image
            ;;
        help|--help|-h)
            show_help
            ;;
        *)
            log_error "Unknown command: ${command}"
            echo ""
            show_help
            exit 1
            ;;
    esac
}

# Run main function
main "$@"
